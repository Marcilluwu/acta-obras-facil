# Arquitectura Offline-First - Patr√≥n Queue and Sync

## üìã Descripci√≥n General

Este proyecto implementa una arquitectura **Offline-First** robusta utilizando el **Patr√≥n Queue and Sync** con **Workbox** y **localForage**. El sistema permite que los usuarios contin√∫en trabajando sin conexi√≥n, encolando autom√°ticamente las operaciones y sincroniz√°ndolas cuando se recupera la conectividad.

## üèóÔ∏è Componentes Principales

### 1. Service Worker (`src/sw.ts`)

**Estrategia:** `injectManifest` (permite l√≥gica personalizada)

**Responsabilidades:**
- Precaching del Application Shell
- Interceptaci√≥n de peticiones POST/PUT fallidas
- Encolamiento autom√°tico usando `workbox-background-sync`
- Comunicaci√≥n con el frontend v√≠a Broadcast Channel API
- Reintento autom√°tico de peticiones encoladas

**Caracter√≠sticas clave:**
```typescript
// Cola de sincronizaci√≥n con manejo de errores
const formQueue = new Queue('form-submissions-queue', {
  onSync: async ({ queue }) => {
    // Procesar cada entrada de la cola
    // Notificar √©xito/error al frontend
  }
});
```

### 2. Capa de Persistencia (`src/lib/outbox.ts`)

**Tecnolog√≠a:** IndexedDB v√≠a `localForage`

**Estructura del Outbox:**
```typescript
interface OutboxEntry {
  localId: string;          // UUID √∫nico del cliente
  endpoint: string;         // URL del API
  method: 'POST' | 'PUT';   // M√©todo HTTP
  payload: any;             // Datos serializados
  timestamp: number;        // Hora de creaci√≥n
  retryCount: number;       // N√∫mero de reintentos
  status: 'pending' | 'syncing' | 'failed' | 'success';
  error?: string;           // Mensaje de error si aplica
}
```

**API Principal:**
- `addToOutbox()` - A√±adir transacci√≥n pendiente
- `getAllOutboxEntries()` - Obtener todas las entradas
- `updateOutboxEntry()` - Actualizar estado
- `removeFromOutbox()` - Eliminar tras √©xito
- `getPendingCount()` - Contador de pendientes

### 3. Hook de Formularios (`src/hooks/useOfflineForm.ts`)

**Funcionalidad:**
- Detecci√≥n de estado de conexi√≥n (online/offline)
- Encolamiento autom√°tico cuando hay errores
- UI Optimista (actualizaci√≥n inmediata de la interfaz)
- Escucha de eventos de sincronizaci√≥n del SW
- Contador de operaciones pendientes

**API del Hook:**
```typescript
const {
  isOnline,              // Estado de conexi√≥n
  pendingCount,          // N√∫mero de operaciones pendientes
  pendingEntries,        // Lista de entradas pendientes
  submitForm,            // Funci√≥n para enviar formularios
  refreshPendingEntries, // Actualizar contador
  retrySync              // Forzar sincronizaci√≥n manual
} = useOfflineForm();
```

### 4. Configuraci√≥n PWA (`vite.config.ts`)

**Plugin:** `vite-plugin-pwa` con estrategia `injectManifest`

```typescript
VitePWA({
  strategies: 'injectManifest',  // ‚úÖ Esencial para l√≥gica personalizada
  srcDir: 'src',
  filename: 'sw.ts',
  registerType: 'autoUpdate',
  // ... configuraci√≥n del manifest
})
```

## üîÑ Flujo de Trabajo Completo

### Escenario 1: Usuario Online

1. Usuario completa el formulario
2. `handleSaveForm()` llama a `submitForm()`
3. Se verifica conexi√≥n con heartbeat (`/ping.txt`)
4. Petici√≥n HTTP normal al servidor
5. ‚úÖ Respuesta exitosa ‚Üí Toast de confirmaci√≥n

### Escenario 2: Usuario Offline (Sin Conexi√≥n)

1. Usuario completa el formulario
2. `submitForm()` detecta `navigator.onLine === false`
3. **Datos se guardan en IndexedDB (Outbox)**
4. Se genera `localId` √∫nico (UUID)
5. **UI Optimista:** Interfaz se actualiza inmediatamente
6. Se intenta registrar `sync` event en Service Worker
7. üíæ Toast: "Datos guardados localmente"
8. **Indicador visual:** Badge muestra "X pendientes"

### Escenario 3: Recuperaci√≥n de Conexi√≥n

1. Navegador detecta `online` event
2. Frontend escucha evento y muestra toast: "üü¢ Conexi√≥n restaurada"
3. Se activa `retrySync()` autom√°ticamente
4. Service Worker ejecuta `queue.replayRequests()`
5. Por cada petici√≥n encolada:
   - Se reintenta el `fetch()`
   - Si √©xito (2xx): elimina de cola y notifica v√≠a Broadcast Channel
   - Si error 4xx: notifica error y no reintenta (error del cliente)
   - Si error 5xx: reencola para nuevo reintento (error del servidor)
6. Frontend escucha Broadcast Channel:
   - `sync_success` ‚Üí Actualiza UI, elimina entrada del outbox
   - `sync_error` ‚Üí Muestra error al usuario

### Escenario 4: Petici√≥n Falla Durante Env√≠o Online

1. Usuario tiene conexi√≥n pero el servidor responde con error
2. `submitForm()` captura el error en `catch`
3. Autom√°ticamente guarda en Outbox
4. Registra sync event
5. Service Worker reintentar√° autom√°ticamente

## üì° Comunicaci√≥n Bidireccional

**Service Worker ‚Üí Frontend** (Broadcast Channel)

```typescript
// En el SW
broadcastChannel.postMessage({
  type: 'sync_success',
  localId: 'abc-123',
  timestamp: Date.now()
});

// En el Frontend
channel.onmessage = (event) => {
  if (event.data.type === 'sync_success') {
    // Actualizar UI
  }
};
```

## üé® Componentes de UI

### Indicadores de Estado

**Badge de Conexi√≥n:**
- üü¢ Verde + Icono Wifi: Online
- üî¥ Rojo + Icono WifiOff: Offline

**Contador de Pendientes:**
- Muestra n√∫mero de operaciones en cola
- Solo visible cuando `pendingCount > 0`

**Bot√≥n de Sincronizaci√≥n Manual:**
- Visible cuando hay pendientes Y est√° online
- Permite forzar reintento inmediato

```tsx
<Badge variant={isOnline ? "default" : "destructive"}>
  {isOnline ? <Wifi /> : <WifiOff />}
  {isOnline ? 'Conectado' : 'Sin conexi√≥n'}
</Badge>

{pendingCount > 0 && (
  <Badge variant="secondary">
    <RefreshCw /> {pendingCount} pendiente(s)
  </Badge>
)}
```

## üîí Idempotencia y Consistencia

### UUID Local (localId)

Cada transacci√≥n genera un `localId` √∫nico usando `uuid.v4()`:

```typescript
const localId = uuidv4();
const payload = { ...data, localId };
```

**Prop√≥sito:**
- Identificar de forma √∫nica cada operaci√≥n
- Prevenir duplicados en el servidor
- Rastrear el estado de sincronizaci√≥n
- Asociar respuestas del SW con entradas del outbox

### Estrategia de Resoluci√≥n de Conflictos

**Server-Centric LWW (Last Write Wins):**
- El timestamp del servidor es la fuente de verdad
- El `localId` permite al servidor detectar duplicados
- El servidor es responsable de la deduplicaci√≥n

## üöÄ Uso en Producci√≥n

### Guardar un Formulario

```typescript
import { useOfflineForm } from '@/hooks/useOfflineForm';

function MyForm() {
  const { submitForm, isOnline, pendingCount } = useOfflineForm();
  
  const handleSubmit = async () => {
    const result = await submitForm(
      '/api/inspections',
      formData,
      'POST'
    );
    
    if (result.queued) {
      // Guardado localmente, se sincronizar√° despu√©s
    } else {
      // Enviado exitosamente al servidor
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      {/* Tu formulario */}
      {pendingCount > 0 && (
        <p>Tienes {pendingCount} formularios pendientes de sincronizar</p>
      )}
    </form>
  );
}
```

### Limpiar Cach√©

```typescript
import { clearOutbox, clearSuccessfulEntries } from '@/lib/outbox';

// Limpiar solo entradas exitosas
await clearSuccessfulEntries();

// Limpiar todo el outbox
await clearOutbox();
```

## üß™ Testing

### Simular Offline

**Chrome DevTools:**
1. Abrir DevTools (F12)
2. Ir a Network tab
3. Cambiar "Online" a "Offline"
4. Enviar formulario ‚Üí debe guardarse localmente
5. Cambiar a "Online"
6. Observar sincronizaci√≥n autom√°tica

**Heartbeat Test:**
El sistema usa `/ping.txt` para verificar conexi√≥n real:

```typescript
async function checkConnection(): Promise<boolean> {
  try {
    const response = await fetch('/ping.txt', {
      method: 'HEAD',
      cache: 'no-cache'
    });
    return response.ok;
  } catch {
    return false;
  }
}
```

## üìä Monitoring

### Console Logs

El sistema emite logs detallados:

```
üöÄ Service Worker activado con soporte Offline-First
üì¶ Entrada a√±adida al Outbox: abc-123
‚úÖ Sincronizaci√≥n exitosa: abc-123
‚ùå Error en sincronizaci√≥n: xyz-789 404
üóëÔ∏è Entrada eliminada del Outbox: abc-123
```

### Inspeccionar IndexedDB

**Chrome DevTools:**
1. Application tab
2. Storage ‚Üí IndexedDB
3. InspectionApp ‚Üí outbox
4. Ver entradas en tiempo real

## üîß Configuraci√≥n Avanzada

### Modificar Reintentos

En `src/sw.ts`, la configuraci√≥n de la Queue:

```typescript
const formQueue = new Queue('form-submissions-queue', {
  maxRetentionTime: 24 * 60, // 24 horas en minutos
  onSync: async ({ queue }) => {
    // L√≥gica personalizada
  }
});
```

### Agregar Endpoints Personalizados

En `useOfflineForm.ts`:

```typescript
// Ejemplo: Actualizar en lugar de crear
await submitForm('/api/inspections/123', data, 'PUT');

// Ejemplo: Eliminar
await submitForm('/api/inspections/123', {}, 'DELETE');
```

## üìö Referencias

- [Workbox Background Sync](https://developer.chrome.com/docs/workbox/modules/workbox-background-sync/)
- [localForage Documentation](https://localforage.github.io/localForage/)
- [Service Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)
- [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API)
- [IndexedDB Best Practices](https://web.dev/indexeddb-best-practices/)

## ‚úÖ Checklist de Implementaci√≥n

- [x] Instalar dependencias (workbox, localforage, uuid)
- [x] Configurar `vite-plugin-pwa` con `injectManifest`
- [x] Crear Service Worker personalizado (`src/sw.ts`)
- [x] Implementar capa de persistencia (`src/lib/outbox.ts`)
- [x] Crear hook de formularios (`src/hooks/useOfflineForm.ts`)
- [x] Registrar Service Worker en `main.tsx`
- [x] Integrar en componente de formulario
- [x] A√±adir indicadores visuales de estado
- [x] Crear archivo `/ping.txt` para heartbeat
- [x] Documentar arquitectura

## üéØ Ventajas de esta Arquitectura

‚úÖ **Experiencia de Usuario Superior:**
- Funciona sin conexi√≥n
- UI optimista (respuesta inmediata)
- Sincronizaci√≥n transparente

‚úÖ **Confiabilidad:**
- Reintentos autom√°ticos
- Persistencia garantizada en IndexedDB
- Manejo robusto de errores

‚úÖ **Escalabilidad:**
- Queue infinita (limitada por espacio en disco)
- Background Sync API usa batching inteligente
- No bloquea el hilo principal

‚úÖ **Consistencia:**
- UUIDs previenen duplicados
- Estrategia LWW server-centric
- Feedback bidireccional SW ‚Üî Frontend

---

**Desarrollado siguiendo las mejores pr√°cticas de Progressive Web Apps (PWA) y Offline-First Architecture.**
